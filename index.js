// Generated by CoffeeScript 1.6.3
(function() {
  var EventEmitter, MariaSQL, TransactionManager,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  EventEmitter = require("events").EventEmitter;

  MariaSQL = require("mariasql");

  TransactionManager = (function(_super) {
    __extends(TransactionManager, _super);

    /*
      Handles a queue of transactions and a pool of MariaSQL connections.
    */


    function TransactionManager(opts) {
      var createConnection,
        _this = this;
      if (!opts) {
        opts = {};
      }
      this.pool = [];
      this.queue = [];
      this.poolsize = opts.poolsize || 20;
      createConnection = function() {
        var conn;
        conn = new MariaSQL();
        conn.connect(opts.connection);
        conn.command = conn.cmd = this.command.bind(this, conn);
        conn.commit = this.commit.bind(this, conn);
        conn.fetchArray = this.fetchArray.bind(this, conn);
        conn.fetchOne = this.fetchOne.bind(this, conn);
        conn.rollback = this.rollback.bind(this, conn);
        return conn;
      };
      this.conn = createConnection.call(this);
      this.conn.on("error", function(err) {
        return _this.emit("error", err);
      });
      this.conn.on("connect", function() {
        var conn, i, waiting, _i, _ref, _results;
        waiting = 0;
        _results = [];
        for (i = _i = 1, _ref = _this.poolsize; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          waiting++;
          conn = createConnection.call(_this);
          _results.push(conn.on("connect", function() {
            var q;
            q = conn.query("SET autocommit = 0");
            q.on("result", function() {});
            q.on("error", function(err) {
              return _this.emit("error", err);
            });
            return q.on("end", function() {
              _this.pool.push(conn);
              waiting--;
              if (waiting <= 0) {
                return _this.emit("init");
              }
            });
          }));
        }
        return _results;
      });
    }

    TransactionManager.prototype.basic = function(callback) {
      /*
        Get a basic, non-transactional connection. (Only for simple queries.)
      */

      var _this = this;
      return setImmediate(function() {
        return typeof callback === "function" ? callback(_this.conn) : void 0;
      });
    };

    TransactionManager.prototype.checkQueue = function() {
      /*
        Check the queue for waiting transaction initializations.
      */

      var callback;
      if (this.queue.length > 0 && this.pool.length > 0) {
        callback = this.queue.shift();
        return typeof callback === "function" ? callback(this.pool.shift()) : void 0;
      }
    };

    TransactionManager.prototype.finalCmd = function(cmd, conn, callback) {
      /*
        Execute rollback or commit.
      */

      var q, reterr,
        _this = this;
      q = conn.query(cmd);
      reterr = null;
      q.on("result", function(res) {
        return res.on("error", function(err) {
          return reterr = err;
        });
      });
      return q.on("end", function() {
        if (typeof callback === "function") {
          callback(reterr);
        }
        _this.pool.push(conn);
        return _this.checkQueue();
      });
    };

    TransactionManager.prototype.commit = function(conn, callback) {
      /*
        Commit a transaction.
      */

      return this.finalCmd("COMMIT", conn, callback);
    };

    TransactionManager.prototype.rollback = function(conn, callback) {
      /*
        Roll back a transaction.
      */

      return this.finalCmd("ROLLBACK", conn, callback);
    };

    TransactionManager.prototype.command = function(conn, sql, params, callback) {
      /*
        Perform an SQL command.
      */

      var q, rerr, ret;
      if (typeof params === "function") {
        callback = params;
        params = {};
      }
      ret = null;
      rerr = null;
      q = conn.query(sql, params);
      q.on("result", function(res) {
        res.on("end", function(info) {
          return ret = info;
        });
        return res.on("error", function(err) {
          return rerr = err;
        });
      });
      return q.on("end", function() {
        return typeof callback === "function" ? callback(rerr, ret) : void 0;
      });
    };

    TransactionManager.prototype.fetchArray = function(conn, sql, params, callback) {
      /*
        Fetch an array of SQL result rows.
      */

      var q, rerr, rows;
      if (typeof params === "function") {
        callback = params;
        params = {};
      }
      rows = [];
      rerr = null;
      q = conn.query(sql, params);
      q.on("result", function(res) {
        res.on("row", function(row) {
          return rows.push(row);
        });
        return res.on("error", function(err) {
          return rerr = err;
        });
      });
      return q.on("end", function() {
        return typeof callback === "function" ? callback(rerr, rows) : void 0;
      });
    };

    TransactionManager.prototype.fetchOne = function(conn, sql, params, callback) {
      /*
        Fetch a single SQL result row.
      */

      var q, rerr, resrow;
      if (typeof params === "function") {
        callback = params;
        params = {};
      }
      resrow = null;
      rerr = null;
      q = conn.query(sql, params);
      q.on("result", function(res) {
        res.on("row", function(row) {
          if (resrow === null) {
            return resrow = row;
          }
        });
        return res.on("error", function(err) {
          return rerr = err;
        });
      });
      return q.on("end", function() {
        return typeof callback === "function" ? callback(rerr, resrow) : void 0;
      });
    };

    TransactionManager.prototype.begin = function() {
      /*
        Attempt to begin a transaction. Add to queue if pool is empty.
      */

      var callback, transact,
        _this = this;
      callback = null;
      transact = true;
      if (arguments.length === 0) {
        return;
      } else if (arguments.length === 1) {
        if (typeof arguments[0] !== "function") {
          return;
        }
        callback = arguments[0];
      } else {
        if (typeof arguments[1] !== "function") {
          return;
        }
        transact = !!arguments[0];
        callback = arguments[1];
      }
      return process.nextTick(function() {
        if (_this.pool.length > 0) {
          return typeof callback === "function" ? callback(_this.pool.shift()) : void 0;
        } else {
          return _this.queue.push(callback);
        }
      });
    };

    return TransactionManager;

  })(EventEmitter);

  module.exports = TransactionManager;

}).call(this);

/*
//@ sourceMappingURL=index.map
*/
